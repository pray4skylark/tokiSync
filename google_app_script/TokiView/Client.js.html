<script>
    const NO_IMAGE_SVG = "data:image/svg+xml;charset=utf-8,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22100%22%20height%3D%22100%22%20viewBox%3D%220%200%20100%20100%22%3E%3Crect%20width%3D%22100%22%20height%3D%22100%22%20fill%3D%22%23333%22%2F%3E%3Ctext%20x%3D%2250%22%20y%3D%2250%22%20font-family%3D%22Arial%22%20font-size%3D%2212%22%20fill%3D%22%23666%22%20text-anchor%3D%22middle%22%20dy%3D%22.3em%22%3ENo%20Image%3C%2Ftext%3E%3C%2Fsvg%3E";
    const URL_NEWTOKI = 'https://newtoki469.com';
    const URL_MANATOKI = 'https://manatoki469.net';
    const URL_BOOKTOKI = 'https://booktoki469.com';

    let allSeries = [];
    let currentBookList = [];
    let currentBookIndex = -1;
    let viewerImages = [];
    let viewerPageIndex = 0;
    let nextBookPreload = null;

    // Feature Flags (State)
    let isScriptConnected = false;
    let scriptCheckTimeout = null;

    // ì´ˆê¸°í™”
    window.onload = function () {
        loadDomains();
        
        // 1. ìŠ¤í¬ë¦½íŠ¸ í†µì‹  ëŒ€ê¸° (3ì´ˆ)
        scriptCheckTimeout = setTimeout(() => {
            if (!isScriptConnected) {
                // ìŠ¤í¬ë¦½íŠ¸ ë¯¸ê°ì§€ -> ì„¤ì • ëª¨ë‹¬ ë„ìš°ê¸° (ìˆ˜ë™ ì…ë ¥ í•„ìš”)
                checkLocalConfig();
            }
        }, 1500); // 1.5ì´ˆ ëŒ€ê¸°

        // 2. ë¶€ëª¨(ìŠ¤í¬ë¦½íŠ¸)ë¡œë¶€í„° ë©”ì‹œì§€ ëŒ€ê¸°
        window.addEventListener("message", handleMessage, false);

        // 3. ë¡œì»¬ ìºì‹œ ìš°ì„  ë¡œë“œ (ë¹ ë¥¸ í™”ë©´ í‘œì‹œ)
        const cachedId = localStorage.getItem('toki_folder_id');
        if (cachedId) {
            refreshDB(cachedId, true); // true = silent load (no spinner reset)
        }
    };

    function handleMessage(event) {
        if (event.data.type === "TOKI_INIT") {
            isScriptConnected = true;
            if (scriptCheckTimeout) clearTimeout(scriptCheckTimeout);

            const folderId = event.data.folderId;
            console.log("ğŸ”— Connected to Script. Root Folder ID:", folderId);
            
            // ì €ì¥ ë° ë¦¬ë¡œë“œ
            if (folderId && folderId !== localStorage.getItem('toki_folder_id')) {
                localStorage.setItem('toki_folder_id', folderId);
                showToast("ğŸ”— ìŠ¤í¬ë¦½íŠ¸ ì—°ê²°ë¨ (ìë™ ë™ê¸°í™”)");
                refreshDB(folderId);
            } else {
                // ì´ë¯¸ ê°™ì€ IDë©´ ë¡œë“œë§Œ ìˆ˜í–‰
                if (!allSeries.length) refreshDB(folderId);
            }
            updateFeatureUI();
        }
    }

    function checkLocalConfig() {
        // ì €ì¥ëœ í´ë” IDê°€ ì—†ìœ¼ë©´ ëª¨ë‹¬ ë„ìš°ê¸°
        if (!localStorage.getItem('toki_folder_id')) {
            document.getElementById('configModal').style.display = 'flex';
        } else {
            // ID ìˆìœ¼ë©´ ë¡œë“œ ì‹œë„ (í•˜ì§€ë§Œ ìŠ¤í¬ë¦½íŠ¸ ì—†ìœ¼ë¯€ë¡œ ì¼ë¶€ ê¸°ëŠ¥ ì œí•œ)
            showToast("âš ï¸ ìŠ¤í¬ë¦½íŠ¸ê°€ ì—°ê²°ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. (ì½ê¸° ì „ìš© ëª¨ë“œ)", 5000);
            updateFeatureUI();
        }
    }

    function saveConfig() {
        const id = document.getElementById('configFolderId').value.trim();
        if(!id) return alert("Folder IDë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”.");
        localStorage.setItem('toki_folder_id', id);
        document.getElementById('configModal').style.display = 'none';
        refreshDB(id);
    }

    function updateFeatureUI() {
        const syncButtons = document.querySelectorAll('.sync-feature');
        const scriptRequired = document.querySelectorAll('.script-only');
        
        // ìŠ¤í¬ë¦½íŠ¸ ì—†ìœ¼ë©´ ë™ê¸°í™” ë²„íŠ¼ ë¹„í™œì„±í™” ìŠ¤íƒ€ì¼ ì ìš©
        if (!isScriptConnected) {
             syncButtons.forEach(btn => btn.classList.add('script-required'));
             // PWA ì„¤ì¹˜ ë²„íŠ¼ í‘œì‹œëŠ” ë³„ë„ ë¡œì§ (ì—¬ê¸°ì„œëŠ” ìƒëµ)
        } else {
             syncButtons.forEach(btn => btn.classList.remove('script-required'));
        }
    }

    // Toast UI
    function showToast(msg, duration = 3000) {
        const toast = document.createElement('div');
        toast.style.position = 'fixed';
        toast.style.bottom = '20px';
        toast.style.left = '50%';
        toast.style.transform = 'translateX(-50%)';
        toast.style.background = 'rgba(50, 50, 50, 0.9)';
        toast.style.color = 'white';
        toast.style.padding = '10px 20px';
        toast.style.borderRadius = '20px';
        toast.style.zIndex = '9999';
        toast.style.fontSize = '14px';
        toast.innerText = msg;
        document.body.appendChild(toast);
        setTimeout(() => toast.remove(), duration);
    }

    function refreshDB(forceId = null, silent = false) {
        const folderId = forceId || localStorage.getItem('toki_folder_id');
        if (!folderId) return;

        if (!silent) {
            const btn = document.getElementById('refreshBtn');
            btn.classList.add('spin-anim');
        }

        google.script.run
            .withSuccessHandler((data) => {
                if (!silent) document.getElementById('refreshBtn').classList.remove('spin-anim');
                renderGrid(data);
            })
            .withFailureHandler((e) => {
                if (!silent) document.getElementById('refreshBtn').classList.remove('spin-anim');
                showToast(`âŒ ê°±ì‹  ì‹¤íŒ¨: ${e.message}`, 5000);
            })
            .getSeriesList(folderId); // Use LibraryService
    }

    function toggleSettings() { document.getElementById('domainPanel').style.display = document.getElementById('domainPanel').style.display === 'block' ? 'none' : 'block'; }
    function saveDomains() {
        localStorage.setItem('url_newtoki', document.getElementById('url_newtoki').value.trim());
        localStorage.setItem('url_manatoki', document.getElementById('url_manatoki').value.trim());
        localStorage.setItem('url_booktoki', document.getElementById('url_booktoki').value.trim());
        renderGrid(allSeries);
    }

    function loadDomains() {
        const n = localStorage.getItem('url_newtoki');
        const m = localStorage.getItem('url_manatoki');
        const b = localStorage.getItem('url_booktoki');

        document.getElementById('url_newtoki').value = n ? n : URL_NEWTOKI;
        document.getElementById('url_manatoki').value = m ? m : URL_MANATOKI;
        document.getElementById('url_booktoki').value = b ? b : URL_BOOKTOKI;
    }

    function getDynamicLink(series) {
        const contentId = series.sourceId;

        const site = (series.name || "").toLowerCase(); // Simple check from name?
        let baseUrl = document.getElementById('url_manatoki').value;
        let path = "/comic/";

        if (site.includes("ë‰´í† ë¼")) { baseUrl = document.getElementById('url_newtoki').value; path = "/webtoon/"; }
        else if (site.includes("ë¶í† ë¼")) { baseUrl = document.getElementById('url_booktoki').value; path = "/novel/"; }

        if (baseUrl.endsWith("/")) baseUrl = baseUrl.slice(0, -1);
        return contentId ? (baseUrl + path + contentId) : "#";
    }

    function renderGrid(seriesList) {
        allSeries = seriesList;
        const grid = document.getElementById('grid');
        grid.innerHTML = '';

        if (!seriesList || seriesList.length === 0) {
            grid.innerHTML = '<div class="no-data">ì €ì¥ëœ ì‘í’ˆì´ ì—†ìŠµë‹ˆë‹¤.</div>';
            document.getElementById('pageLoader').style.display = 'none';
            return;
        }

        seriesList.forEach((series, index) => {
            try {
                const card = document.createElement('div');
                card.className = 'card';

                // Defensive Coding
                const meta = series.metadata || { status: 'Unknown', authors: [] };
                const authors = meta.authors || [];
                const status = meta.status || 'Unknown';

                const thumb = series.thumbnail && series.thumbnail.startsWith("data:image") ? series.thumbnail : NO_IMAGE_SVG;
                const dynamicUrl = getDynamicLink(series);
                const hasContentId = !!series.sourceId;

                card.innerHTML = `
      <div class="thumb-wrapper">
        <img src="${thumb}" class="thumb" onerror="this.src='${NO_IMAGE_SVG}'">
        <div class="overlay">
          <a href="${series.url}" target="_blank" class="btn btn-drive">ğŸ“‚ ë“œë¼ì´ë¸Œ</a>
          <button onclick="openEpisodeList('${series.id}', '${series.name}', ${index})" class="btn" style="background:#444; color:white;">ğŸ“„ ëª©ë¡</button>
          ${hasContentId ? `
              <a href="${dynamicUrl}" target="_blank" class="btn btn-site">ğŸŒ ì‚¬ì´íŠ¸</a>
              <a href="${dynamicUrl}?toki_action=sync" target="_blank" class="btn sync-feature" style="background:#ff9800; color:black;">âš¡ï¸ ë™ê¸°í™”</a>
          ` : ''}
        </div>
      </div>
      <div class="info">
        <div class="title" title="${series.name}">${series.name}</div>
        <span class="author" title="${authors.join(', ')}">${authors.join(', ') || 'ì‘ê°€ ë¯¸ìƒ'}</span>
        <div class="meta">
          <span class="badge">${status}</span>
          <span class="count">${series.booksCount || 0}ê¶Œ</span>
        </div>
      </div>
    `;
                grid.appendChild(card);
            } catch (err) {
                console.error("Error rendering item index " + index, err);
            }
        });
        updateFeatureUI(); // ë Œë”ë§ í›„ ë²„íŠ¼ ìƒíƒœ ì—…ë°ì´íŠ¸
        document.getElementById('pageLoader').style.display = 'none';
    }

    function filterData() {
        const query = document.getElementById('search').value.toLowerCase();
        const cards = document.querySelectorAll('.card');
        cards.forEach((card, index) => {
            const series = allSeries[index];
            const meta = series.metadata || { authors: [] };
            const authors = meta.authors || [];
            const text = (series.name + (authors.join(' '))).toLowerCase();
            card.style.display = text.includes(query) ? 'flex' : 'none';
        });
    }
    function togglePwaGuide() {
        const guide = document.getElementById('pwaGuide');
        if (guide.style.display === 'block') {
            guide.style.display = 'none';
        } else {
            guide.style.display = 'block';
        }
    }

    // [Episode List Logic]
    function openEpisodeList(seriesId, title, seriesIndex) {
        document.getElementById('episodeModal').style.display = 'flex';
        document.querySelector('#episodeModal .modal-title').innerText = `ğŸ“„ ${title}`;
        const listEl = document.getElementById('episodeList');
        listEl.innerHTML = '<div style="padding:20px; color:#888;">ë¡œë”© ì¤‘...</div>';
        console.log('seriesId', seriesId);
        console.log('title', title);
        console.log('seriesIndex', seriesIndex);
        google.script.run
            .withSuccessHandler((books) => {
                document.querySelector('#episodeModal .modal-title').innerText = `ğŸ“„ ${title} (${books ? books.length : 0}ê°œ)`;
                renderEpisodeList(books, seriesIndex);
            })
            .withFailureHandler(e => {
                listEl.innerHTML = `<div style="padding:20px; color:red;">ì˜¤ë¥˜: ${e.message}</div>`;
            })
            .getBooks(seriesId); // Use BookService
    }

    function closeEpisodeModal() {
        document.getElementById('episodeModal').style.display = 'none';
    }

    function renderEpisodeList(books, seriesIndex) {
        currentBookList = books || [];
        const listEl = document.getElementById('episodeList');
        listEl.innerHTML = '';

        if (!books || books.length === 0) {
            listEl.innerHTML = '<div style="padding:20px; color:#888;">í‘œì‹œí•  íšŒì°¨ê°€ ì—†ìŠµë‹ˆë‹¤.</div>';
            return;
        }

        books.forEach((book, index) => {
            try {
                const div = document.createElement('div');
                div.className = 'episode-item';

                let icon = 'ğŸ“';
                let meta = 'í´ë”';
                let clickHandler = () => window.open(book.url, '_blank');

                if (book.media && book.media.mediaType && !book.media.mediaType.includes('folder')) {
                    icon = 'ğŸ“¦';
                    // Safe formatSize check
                    meta = (typeof formatSize === 'function') ? formatSize(book.size) : (book.size + ' B');

                    // Check extension from name
                    if (book.name.toLowerCase().endsWith('.cbz') || book.name.toLowerCase().endsWith('.zip')) {
                        icon = 'ğŸ“–';
                        clickHandler = () => {
                            if (confirm(`"${book.name}"\nì •ì£¼í–‰ì„ ì‹œì‘í•˜ì‹œê² ìŠµë‹ˆê¹Œ?`)) {
                                loadViewer(index);
                            }
                        };
                    }
                } else {
                    // Folder
                    icon = 'ğŸ“';
                }

                div.innerHTML = `
                    <div>
                        <span style="margin-right:10px;">${icon}</span>
                        <span class="ep-name">${book.name}</span>
                    </div>
                    <span class="ep-meta">${meta}</span>
                `;
                div.onclick = clickHandler;
                listEl.appendChild(div);

            } catch (err) {
                console.error("Error rendering item index " + index, book, err);
                // Show error item in list
                const errDiv = document.createElement('div');
                errDiv.style.color = "red";
                errDiv.innerText = `[Render Error] ${book ? book.name : 'Unknown Item'}`;
                listEl.appendChild(errDiv);
            }
        });
    }

    function formatSize(bytes) {
        if (bytes === 0) return '0 B';
        const k = 1024;
        const sizes = ['B', 'KB', 'MB', 'GB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i];
    }

    // [Viewer Logic]
    async function loadViewer(index) {
        const book = currentBookList[index];
        if (!book) return;

        closeEpisodeModal();
        currentBookIndex = index;
        viewerPageIndex = 0;

        const viewer = document.getElementById('viewerOverlay');
        const content = document.getElementById('viewerContent');
        const titleEl = document.getElementById('viewerTitle');

        viewer.style.display = 'flex';
        document.body.classList.add('no-scroll');

        titleEl.innerText = book.name;

        content.innerHTML = `
        <div class="nav-zone nav-prev" onclick="navigateViewer(-1)">â®</div>
            <div class="nav-zone nav-next" onclick="navigateViewer(1)">â¯</div>
            <div id="viewerImageContainer" style="width:100%; height:100%; display:flex; justify-content:center; align-items:center;">
                 <div style="color:white; font-size:14px;">ë¡œë”© ì¤‘... (0%)</div>
            </div>
            <div id="pageCounter" class="page-counter">- / -</div>
    `;

        try {
            let images = [];
            // Check Preload
            if (nextBookPreload && nextBookPreload.index === index) {
                console.log("Using preloaded data!");
                images = nextBookPreload.images;
                nextBookPreload = null;
            } else {
                images = await fetchAndUnzip(book.id, (progress) => {
                    const el = document.querySelector('#viewerImageContainer div');
                    if (el) el.innerText = progress;
                });
            }

            if (images.length === 0) throw new Error("ì´ë¯¸ì§€ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.");

            viewerImages = images;
            renderViewerPage(0);

        } catch (e) {
            alert("ë·°ì–´ ë¡œë“œ ì‹¤íŒ¨: " + e.message);
            closeViewer();
        }
    }

    async function fetchAndUnzip(fileId, onProgress) {
        const chunks = [];
        let offset = 0;
        let totalLength = 0;
        const CHUNK_SIZE = 10 * 1024 * 1024; // 10MB

        // 1. Download Chunks
        while (true) {
            const response = await new Promise((resolve, reject) => {
                google.script.run
                    .withSuccessHandler(resolve)
                    .withFailureHandler(reject)
                    .getFileChunk(fileId, offset, CHUNK_SIZE); // Use BookService
            });

            if (!response) break;

            const binaryString = atob(response.data);
            const len = binaryString.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) {
                bytes[i] = binaryString.charCodeAt(i);
            }

            chunks.push(bytes);
            totalLength += len;
            offset = response.nextOffset;

            const percent = Math.round((offset / response.totalSize) * 100);
            if (onProgress) onProgress(`íŒŒì¼ ë‹¤ìš´ë¡œë“œ ì¤‘... (${percent}%)`);

            if (!response.hasMore) break;
        }

        // 2. Merge & Unzip
        if (onProgress) onProgress('ì´ë¯¸ì§€ ì••ì¶• í•´ì œ ì¤‘...');
        const combinedBytes = new Uint8Array(totalLength);
        let position = 0;
        for (const chunk of chunks) {
            combinedBytes.set(chunk, position);
            position += chunk.length;
        }

        const zip = await JSZip.loadAsync(combinedBytes);

        // 3. Extract Images
        const files = Object.keys(zip.files).sort((a, b) => {
            return a.localeCompare(b, undefined, { numeric: true, sensitivity: 'base' });
        });

        const imageUrls = [];
        for (const filename of files) {
            if (filename.match(/\.(jpg|jpeg|png|webp|gif)$/i)) {
                const blob = await zip.files[filename].async('blob');
                imageUrls.push(URL.createObjectURL(blob));
            }
        }
        return imageUrls;
    }

    function renderViewerPage(pageIndex) {
        if (pageIndex < 0 || pageIndex >= viewerImages.length) return;

        viewerPageIndex = pageIndex;
        const container = document.getElementById('viewerImageContainer');
        const counter = document.getElementById('pageCounter');

        container.innerHTML = '';

        const img = document.createElement('img');
        img.src = viewerImages[pageIndex];
        img.className = 'viewer-image';
        container.appendChild(img);

        counter.innerText = `${pageIndex + 1} / ${viewerImages.length}`;

        // Preload Trigger (Last 5 pages)
        if (viewerImages.length - pageIndex <= 5) {
            preloadNextEpisode();
        }
    }

    function navigateViewer(dir) {
        const nextIndex = viewerPageIndex + dir;

        if (nextIndex >= viewerImages.length) {
            // End of episode
            if (currentBookIndex < currentBookList.length - 1) {
                // Next episode exists
                if (confirm("ë‹¤ìŒ í™”ë¡œ ì´ë™í•˜ì‹œê² ìŠµë‹ˆê¹Œ?")) {
                    loadViewer(currentBookIndex + 1);
                }
            } else {
                showToast("ë§ˆì§€ë§‰ í™”ì…ë‹ˆë‹¤.");
            }
            return;
        }

        if (nextIndex < 0) {
            showToast("ì²« í˜ì´ì§€ì…ë‹ˆë‹¤.");
            return;
        }

        renderViewerPage(nextIndex);
    }

    function preloadNextEpisode() {
        const nextIndex = currentBookIndex + 1;
        if (nextIndex >= currentBookList.length) return;

        // Check if already preloaded or preloading
        if (nextBookPreload && nextBookPreload.index === nextIndex) return;

        if (window.isPreloading) return;

        console.log("Preloading next episode:", currentBookList[nextIndex].name);
        window.isPreloading = true;

        fetchAndUnzip(currentBookList[nextIndex].id, null)
            .then(images => {
                nextBookPreload = { index: nextIndex, images: images };
                console.log("Preload complete");
                showToast("ğŸ“¦ ë‹¤ìŒ í™” ì¤€ë¹„ ì™„ë£Œ!", 3000);
                window.isPreloading = false;
            })
            .catch(e => {
                console.error("Preload failed", e);
                window.isPreloading = false;
            });
    }

    function closeViewer() {
        const viewer = document.getElementById('viewerOverlay');
        const content = document.getElementById('viewerContent');

        // Cleanup Blob URLs
        if (viewerImages) {
            viewerImages.forEach(url => URL.revokeObjectURL(url));
        }
        viewerImages = [];

        content.innerHTML = '';
        viewer.style.display = 'none';
        document.body.classList.remove('no-scroll');
    }

    // Global Keydown Handler
    document.addEventListener('keydown', (e) => {
        if (document.getElementById('viewerOverlay').style.display === 'flex') {
            if (e.key === 'Escape') closeViewer();
            else if (e.key === 'ArrowLeft') navigateViewer(-1);
            else if (e.key === 'ArrowRight') navigateViewer(1);
            else if (e.key === ' ' || e.key === 'Enter') navigateViewer(1);
        } else if (document.getElementById('episodeModal').style.display === 'flex') {
            if (e.key === 'Escape') closeEpisodeModal();
        }
    });
</script>
